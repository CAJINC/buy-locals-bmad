# Story 4.4: Community Engagement Features

## Status
Approved

## Story
**As a** community member,
**I want** to engage with local business content and connect with other community members,
**so that** I can discover recommendations, share experiences, and build local connections.

## Acceptance Criteria
1. Business update feed shows recent photos, announcements, and special offers from followed businesses
2. Community activity stream displays recent reviews, new business openings, and popular local content
3. User follow system allows consumers to follow favorite businesses for updates
4. Recommendation system suggests businesses based on user preferences and community activity
5. Social sharing capabilities allow users to share business profiles and reviews on external platforms
6. Local community groups organized by neighborhood or interests for targeted discussions
7. Event integration shows business-hosted events and community gatherings
8. User profile displays review contributions, community activity, and local engagement metrics

## Tasks / Subtasks
- [ ] **Task 1: Business Update Feed System** (AC: 1)
  - [ ] Create business update posting interface for business owners
  - [ ] Implement update feed with photos, announcements, and offers
  - [ ] Add update categorization and tagging system
  - [ ] Create feed filtering and personalization algorithms
  - [ ] Implement update engagement metrics (views, likes, shares)
  - [ ] Add update scheduling and promotion features
  - [ ] Create update analytics dashboard for businesses

- [ ] **Task 2: Community Activity Stream** (AC: 2)
  - [ ] Create centralized community activity aggregation service
  - [ ] Implement activity stream with real-time updates
  - [ ] Add activity filtering by type, location, and relevance
  - [ ] Create trending content identification algorithms
  - [ ] Implement activity notification preferences
  - [ ] Add community milestone celebrations
  - [ ] Create activity analytics and insights

- [ ] **Task 3: Business Follow System** (AC: 3)
  - [ ] Implement user-business follow relationships
  - [ ] Create follow/unfollow interface components
  - [ ] Add follower count and following list displays
  - [ ] Implement follow-based content personalization
  - [ ] Create follower notification systems
  - [ ] Add follow analytics for businesses
  - [ ] Implement follow-based recommendation improvements

- [ ] **Task 4: Recommendation Engine** (AC: 4)
  - [ ] Create user preference learning algorithms
  - [ ] Implement collaborative filtering for business recommendations
  - [ ] Add location-based recommendation weighting
  - [ ] Create category and service preference tracking
  - [ ] Implement social proof in recommendations
  - [ ] Add recommendation explanation and feedback
  - [ ] Create recommendation performance analytics

- [ ] **Task 5: Social Sharing Integration** (AC: 5)
  - [ ] Implement social media sharing APIs (Facebook, Twitter, Instagram)
  - [ ] Create shareable content generation for businesses and reviews
  - [ ] Add social media preview optimization (Open Graph, Twitter Cards)
  - [ ] Implement sharing analytics and tracking
  - [ ] Create custom sharing templates and branding
  - [ ] Add viral coefficient tracking and optimization
  - [ ] Implement referral reward systems for sharing

- [ ] **Task 6: Local Community Groups** (AC: 6)
  - [ ] Create neighborhood-based community group system
  - [ ] Implement interest-based group categorization
  - [ ] Add group creation and management interfaces
  - [ ] Create group discussion and messaging features
  - [ ] Implement group event planning and coordination
  - [ ] Add group moderation and administration tools
  - [ ] Create group discovery and recommendation system

- [ ] **Task 7: Event Integration System** (AC: 7)
  - [ ] Create business event creation and management interface
  - [ ] Implement event discovery and search functionality
  - [ ] Add event attendance tracking and RSVP system
  - [ ] Create event reminder and notification system
  - [ ] Implement event sharing and promotion features
  - [ ] Add event analytics and success metrics
  - [ ] Create community event calendar integration

- [ ] **Task 8: User Profile and Engagement Metrics** (AC: 8)
  - [ ] Create comprehensive user profile with community contributions
  - [ ] Implement engagement scoring and reputation system
  - [ ] Add review contribution statistics and badges
  - [ ] Create local influence metrics and rankings
  - [ ] Implement achievement and milestone systems
  - [ ] Add community contribution recognition features
  - [ ] Create engagement analytics and insights dashboard

- [ ] **Task 9: Backend Community Services** (AC: 1, 2, 3, 4)
  - [ ] Create POST /community/updates for business updates
  - [ ] Implement GET /community/feed for activity streams
  - [ ] Add POST /users/{id}/follow for follow relationships
  - [ ] Create GET /recommendations for personalized suggestions
  - [ ] Implement community content aggregation services
  - [ ] Add recommendation engine processing pipelines
  - [ ] Create community analytics and metrics endpoints

## Dev Notes

### Previous Story Insights
Story 4.3 established review quality control. This story creates the social engagement layer that transforms the platform from a simple business directory into a vibrant local community platform that encourages ongoing participation and connection.

### Business Update Feed Architecture
**Content Management and Distribution:**
```typescript
interface BusinessUpdateService {
  createUpdate(params: UpdateCreationParams): Promise<BusinessUpdate>;
  getFeedForUser(userId: string, filters: FeedFilters): Promise<FeedItem[]>;
  engageWithUpdate(updateId: string, userId: string, action: EngagementAction): Promise<void>;
  getUpdateAnalytics(businessId: string, period: DateRange): Promise<UpdateAnalytics>;
}

interface BusinessUpdate {
  id: string;
  businessId: string;
  type: 'photo' | 'announcement' | 'offer' | 'event' | 'milestone';
  title: string;
  content: string;
  media: MediaItem[];
  tags: string[];
  targetAudience: 'all' | 'followers' | 'local' | 'segment';
  scheduledAt?: Date;
  expiresAt?: Date;
  engagement: UpdateEngagement;
  visibility: 'public' | 'followers_only' | 'local_only';
  createdAt: Date;
  updatedAt: Date;
}

interface UpdateEngagement {
  views: number;
  likes: number;
  shares: number;
  comments: number;
  clickthroughs: number;
  conversions: number;
}

interface FeedItem {
  id: string;
  type: 'business_update' | 'new_review' | 'business_opening' | 'community_milestone';
  content: BusinessUpdate | Review | Business | CommunityMilestone;
  relevanceScore: number;
  personalizedReason?: string;
  timestamp: Date;
}

// Business update feed generation
const generatePersonalizedFeed = async (userId: string, limit: number = 20): Promise<FeedItem[]> => {
  const user = await getUserById(userId);
  const followedBusinesses = await getFollowedBusinesses(userId);
  const userPreferences = await getUserPreferences(userId);
  const userLocation = user.profile.locationPreferences;

  let feedItems: FeedItem[] = [];

  // Get updates from followed businesses (high priority)
  const followedUpdates = await getBusinessUpdates({
    businessIds: followedBusinesses.map(b => b.id),
    limit: Math.floor(limit * 0.4)
  });

  feedItems.push(...followedUpdates.map(update => ({
    id: `update_${update.id}`,
    type: 'business_update' as const,
    content: update,
    relevanceScore: 0.9,
    personalizedReason: `From ${update.business.name} (following)`,
    timestamp: update.createdAt
  })));

  // Get local business updates (medium priority)
  const localUpdates = await getBusinessUpdates({
    location: userLocation,
    radius: userPreferences.discoveryRadius || 10,
    excludeBusinessIds: followedBusinesses.map(b => b.id),
    limit: Math.floor(limit * 0.3)
  });

  feedItems.push(...localUpdates.map(update => ({
    id: `local_${update.id}`,
    type: 'business_update' as const,
    content: update,
    relevanceScore: calculateLocationRelevance(update.business.location, userLocation),
    personalizedReason: `Popular in your area`,
    timestamp: update.createdAt
  })));

  // Get recent reviews from community
  const communityReviews = await getRecentReviews({
    location: userLocation,
    radius: userPreferences.discoveryRadius || 10,
    limit: Math.floor(limit * 0.2)
  });

  feedItems.push(...communityReviews.map(review => ({
    id: `review_${review.id}`,
    type: 'new_review' as const,
    content: review,
    relevanceScore: review.rating >= 4 ? 0.7 : 0.5,
    personalizedReason: `New review in your area`,
    timestamp: review.createdAt
  })));

  // Sort by relevance and recency
  return feedItems
    .sort((a, b) => {
      const scoreA = a.relevanceScore * 0.7 + (Date.now() - a.timestamp.getTime()) / (1000 * 60 * 60 * 24) * 0.3;
      const scoreB = b.relevanceScore * 0.7 + (Date.now() - b.timestamp.getTime()) / (1000 * 60 * 60 * 24) * 0.3;
      return scoreB - scoreA;
    })
    .slice(0, limit);
};
```

### Follow System Implementation
**User-Business Relationship Management:**
```typescript
interface FollowService {
  followBusiness(userId: string, businessId: string): Promise<void>;
  unfollowBusiness(userId: string, businessId: string): Promise<void>;
  getFollowedBusinesses(userId: string): Promise<Business[]>;
  getBusinessFollowers(businessId: string): Promise<User[]>;
  getFollowStats(businessId: string): Promise<FollowStats>;
  isFollowing(userId: string, businessId: string): Promise<boolean>;
}

interface FollowStats {
  followerCount: number;
  followerGrowth: GrowthMetric[];
  followerDemographics: Demographics;
  engagementRate: number;
  topFollowers: TopFollower[];
}

interface TopFollower {
  user: User;
  engagementScore: number;
  followedSince: Date;
  totalInteractions: number;
}

// Follow system component
export const FollowButton: React.FC<FollowButtonProps> = ({
  business,
  userId,
  onFollowChange
}) => {
  const [isFollowing, setIsFollowing] = useState(false);
  const [followerCount, setFollowerCount] = useState(business.followerCount || 0);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const checkFollowStatus = async () => {
      if (userId) {
        const following = await followService.isFollowing(userId, business.id);
        setIsFollowing(following);
      }
    };
    checkFollowStatus();
  }, [userId, business.id]);

  const handleToggleFollow = async () => {
    if (!userId) return;

    setLoading(true);
    try {
      if (isFollowing) {
        await followService.unfollowBusiness(userId, business.id);
        setIsFollowing(false);
        setFollowerCount(prev => prev - 1);
        onFollowChange?.(false);
      } else {
        await followService.followBusiness(userId, business.id);
        setIsFollowing(true);
        setFollowerCount(prev => prev + 1);
        onFollowChange?.(true);
      }
    } catch (error) {
      console.error('Error toggling follow:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <FollowContainer>
      <FollowActionButton
        onPress={handleToggleFollow}
        disabled={loading}
        variant={isFollowing ? 'following' : 'follow'}
      >
        {loading ? (
          <LoadingSpinner size="small" />
        ) : (
          <>
            <FollowIcon name={isFollowing ? 'heart-filled' : 'heart-outline'} />
            <FollowText>
              {isFollowing ? 'Following' : 'Follow'}
            </FollowText>
          </>
        )}
      </FollowActionButton>

      <FollowerCount>
        {formatCount(followerCount)} followers
      </FollowerCount>
    </FollowContainer>
  );
};
```

### Recommendation Engine
**Personalized Business Discovery:**
```typescript
interface RecommendationService {
  getPersonalizedRecommendations(userId: string, options: RecommendationOptions): Promise<BusinessRecommendation[]>;
  getLocationBasedRecommendations(location: Location, options: RecommendationOptions): Promise<BusinessRecommendation[]>;
  getTrendingBusinesses(location: Location, timeframe: TimeFrame): Promise<Business[]>;
  updateUserPreferences(userId: string, preferences: UserPreferences): Promise<void>;
}

interface BusinessRecommendation {
  business: Business;
  score: number;
  reasons: RecommendationReason[];
  confidence: number;
  category: 'trending' | 'similar_taste' | 'location_based' | 'social_proof';
}

interface RecommendationReason {
  type: 'similar_users' | 'location_proximity' | 'category_interest' | 'social_connection' | 'trending';
  description: string;
  weight: number;
}

interface UserPreferences {
  categories: CategoryPreference[];
  priceRange: [number, number];
  discoveryRadius: number;
  preferredTimes: TimePreference[];
  avoidCategories: string[];
  socialWeight: number; // How much to weight social connections
}

// Collaborative filtering recommendation algorithm
const generateCollaborativeRecommendations = async (userId: string): Promise<BusinessRecommendation[]> => {
  // Find users with similar preferences
  const userReviews = await getUserReviews(userId);
  const userCategories = extractCategoriesFromReviews(userReviews);
  const userRatingPattern = analyzeRatingPattern(userReviews);

  const similarUsers = await findSimilarUsers(userId, {
    categoryOverlap: 0.6,
    ratingCorrelation: 0.7,
    locationProximity: 50 // miles
  });

  // Get businesses highly rated by similar users that target user hasn't tried
  const recommendations: BusinessRecommendation[] = [];

  for (const similarUser of similarUsers) {
    const theirHighRatedBusinesses = await getUserHighRatedBusinesses(similarUser.id, 4.0);

    for (const business of theirHighRatedBusinesses) {
      // Skip if user already reviewed this business
      if (userReviews.some(r => r.businessId === business.id)) continue;

      const similarity = calculateUserSimilarity(userId, similarUser.id);
      const businessScore = calculateBusinessScore(business, userPreferences);

      const recommendation: BusinessRecommendation = {
        business,
        score: similarity * businessScore,
        reasons: [
          {
            type: 'similar_users',
            description: `Users with similar taste rated this ${business.averageRating}â­`,
            weight: similarity
          }
        ],
        confidence: similarity,
        category: 'similar_taste'
      };

      recommendations.push(recommendation);
    }
  }

  return recommendations
    .sort((a, b) => b.score - a.score)
    .slice(0, 10);
};
```

### Social Sharing Integration
**External Platform Sharing:**
```typescript
interface SocialSharingService {
  generateShareableContent(contentType: 'business' | 'review' | 'event', contentId: string): Promise<ShareableContent>;
  shareToFacebook(content: ShareableContent, accessToken: string): Promise<ShareResult>;
  shareToTwitter(content: ShareableContent, accessToken: string): Promise<ShareResult>;
  shareToInstagram(content: ShareableContent, accessToken: string): Promise<ShareResult>;
  trackShare(shareId: string, platform: string, userId: string): Promise<void>;
  getShareAnalytics(contentId: string, period: DateRange): Promise<ShareAnalytics>;
}

interface ShareableContent {
  id: string;
  title: string;
  description: string;
  imageUrl: string;
  url: string;
  hashtags: string[];
  socialMediaPreviews: {
    facebook: OpenGraphData;
    twitter: TwitterCardData;
    instagram: InstagramData;
  };
}

interface OpenGraphData {
  title: string;
  description: string;
  image: string;
  url: string;
  siteName: string;
  type: string;
}

// Social sharing component
export const SocialShareButton: React.FC<SocialShareProps> = ({
  content,
  platform,
  onShareComplete
}) => {
  const [sharing, setSharing] = useState(false);

  const handleShare = async () => {
    setSharing(true);

    try {
      const shareableContent = await socialSharingService.generateShareableContent(
        content.type,
        content.id
      );

      let shareResult: ShareResult;

      switch (platform) {
        case 'facebook':
          shareResult = await socialSharingService.shareToFacebook(
            shareableContent,
            await getFacebookAccessToken()
          );
          break;
        case 'twitter':
          shareResult = await socialSharingService.shareToTwitter(
            shareableContent,
            await getTwitterAccessToken()
          );
          break;
        case 'instagram':
          shareResult = await socialSharingService.shareToInstagram(
            shareableContent,
            await getInstagramAccessToken()
          );
          break;
        case 'native':
          shareResult = await Share.share({
            title: shareableContent.title,
            message: shareableContent.description,
            url: shareableContent.url
          });
          break;
        default:
          throw new Error(`Unsupported platform: ${platform}`);
      }

      if (shareResult.success) {
        await socialSharingService.trackShare(
          shareableContent.id,
          platform,
          content.userId
        );
        onShareComplete?.(shareResult);
      }
    } catch (error) {
      console.error('Share failed:', error);
    } finally {
      setSharing(false);
    }
  };

  const platformConfig = {
    facebook: { icon: 'facebook', color: '#1877F2', label: 'Facebook' },
    twitter: { icon: 'twitter', color: '#1DA1F2', label: 'Twitter' },
    instagram: { icon: 'instagram', color: '#E4405F', label: 'Instagram' },
    native: { icon: 'share', color: '#666', label: 'Share' }
  };

  const config = platformConfig[platform];

  return (
    <ShareButton
      onPress={handleShare}
      disabled={sharing}
      style={{ backgroundColor: config.color }}
    >
      {sharing ? (
        <LoadingSpinner color="white" size="small" />
      ) : (
        <>
          <ShareIcon name={config.icon} color="white" />
          <ShareLabel>{config.label}</ShareLabel>
        </>
      )}
    </ShareButton>
  );
};
```

### Community Groups System
**Neighborhood and Interest-Based Communities:**
```typescript
interface CommunityGroupService {
  createGroup(params: GroupCreationParams): Promise<CommunityGroup>;
  joinGroup(groupId: string, userId: string): Promise<void>;
  leaveGroup(groupId: string, userId: string): Promise<void>;
  getGroupsByLocation(location: Location, radius: number): Promise<CommunityGroup[]>;
  getGroupsByInterest(interests: string[]): Promise<CommunityGroup[]>;
  postToGroup(groupId: string, post: GroupPost): Promise<void>;
  moderateGroup(groupId: string, action: ModerationAction): Promise<void>;
}

interface CommunityGroup {
  id: string;
  name: string;
  description: string;
  type: 'neighborhood' | 'interest' | 'business_type' | 'event_based';
  location?: Location;
  interests: string[];
  memberCount: number;
  privacy: 'public' | 'private' | 'invitation_only';
  rules: string[];
  moderators: string[];
  createdBy: string;
  createdAt: Date;
  lastActivity: Date;
}

interface GroupPost {
  id: string;
  groupId: string;
  authorId: string;
  type: 'discussion' | 'recommendation' | 'event' | 'announcement';
  title: string;
  content: string;
  media: MediaItem[];
  tags: string[];
  pinned: boolean;
  engagement: PostEngagement;
  createdAt: Date;
}

// Community group interface
export const CommunityGroupCard: React.FC<CommunityGroupCardProps> = ({
  group,
  userId,
  onJoin,
  onLeave
}) => {
  const [isMember, setIsMember] = useState(false);
  const [memberCount, setMemberCount] = useState(group.memberCount);

  useEffect(() => {
    const checkMembership = async () => {
      const membership = await communityService.checkGroupMembership(group.id, userId);
      setIsMember(membership.isMember);
    };
    checkMembership();
  }, [group.id, userId]);

  const handleJoinLeave = async () => {
    try {
      if (isMember) {
        await communityService.leaveGroup(group.id, userId);
        setIsMember(false);
        setMemberCount(prev => prev - 1);
        onLeave?.(group);
      } else {
        await communityService.joinGroup(group.id, userId);
        setIsMember(true);
        setMemberCount(prev => prev + 1);
        onJoin?.(group);
      }
    } catch (error) {
      console.error('Error toggling group membership:', error);
    }
  };

  return (
    <GroupCard>
      <GroupHeader>
        <GroupIcon type={group.type} />
        <GroupInfo>
          <GroupName>{group.name}</GroupName>
          <GroupMeta>
            <MemberCount>{formatCount(memberCount)} members</MemberCount>
            <GroupType>{group.type.replace('_', ' ')}</GroupType>
          </GroupMeta>
        </GroupInfo>
      </GroupHeader>

      <GroupDescription>{group.description}</GroupDescription>

      <GroupTags>
        {group.interests.map(interest => (
          <GroupTag key={interest}>{interest}</GroupTag>
        ))}
      </GroupTags>

      <GroupStats>
        <StatItem>
          <StatIcon name="calendar" />
          <StatText>Last active {formatRelativeTime(group.lastActivity)}</StatText>
        </StatItem>
        {group.location && (
          <StatItem>
            <StatIcon name="location" />
            <StatText>{group.location.city}, {group.location.state}</StatText>
          </StatItem>
        )}
      </GroupStats>

      <GroupActions>
        <JoinButton
          onPress={handleJoinLeave}
          variant={isMember ? 'joined' : 'join'}
        >
          {isMember ? 'Leave Group' : 'Join Group'}
        </JoinButton>
        <ViewGroupButton
          onPress={() => navigateToGroup(group.id)}
        >
          View Group
        </ViewGroupButton>
      </GroupActions>
    </GroupCard>
  );
};
```

### Event Integration System
**Community Event Management:**
```typescript
interface EventService {
  createEvent(params: EventCreationParams): Promise<CommunityEvent>;
  rsvpToEvent(eventId: string, userId: string, response: RSVPResponse): Promise<void>;
  getEventsByLocation(location: Location, radius: number, timeframe: TimeFrame): Promise<CommunityEvent[]>;
  getEventsByBusiness(businessId: string): Promise<CommunityEvent[]>;
  updateEvent(eventId: string, updates: EventUpdates): Promise<void>;
  sendEventReminders(eventId: string): Promise<void>;
}

interface CommunityEvent {
  id: string;
  title: string;
  description: string;
  type: 'business_hosted' | 'community_organized' | 'seasonal' | 'promotional';
  organizer: Organizer;
  venue: EventVenue;
  datetime: EventDateTime;
  capacity?: number;
  ticketPrice?: number;
  categories: string[];
  media: MediaItem[];
  rsvpCount: number;
  attendanceTracking: boolean;
  requiresApproval: boolean;
  visibility: 'public' | 'followers_only' | 'group_only';
  createdAt: Date;
  updatedAt: Date;
}

interface EventVenue {
  type: 'business_location' | 'public_space' | 'virtual' | 'other';
  businessId?: string;
  address?: Address;
  virtualLink?: string;
  specialInstructions?: string;
}

interface RSVPResponse {
  response: 'attending' | 'maybe' | 'not_attending';
  guestCount?: number;
  notes?: string;
}

// Event discovery and RSVP component
export const EventCard: React.FC<EventCardProps> = ({
  event,
  userId,
  onRSVP
}) => {
  const [rsvpStatus, setRSVPStatus] = useState<RSVPResponse | null>(null);
  const [rsvpCount, setRSVPCount] = useState(event.rsvpCount);

  useEffect(() => {
    const loadRSVPStatus = async () => {
      if (userId) {
        const status = await eventService.getRSVPStatus(event.id, userId);
        setRSVPStatus(status);
      }
    };
    loadRSVPStatus();
  }, [event.id, userId]);

  const handleRSVP = async (response: RSVPResponse) => {
    try {
      await eventService.rsvpToEvent(event.id, userId, response);
      setRSVPStatus(response);

      // Update RSVP count
      const countChange = response.response === 'attending' ? 1 :
                         rsvpStatus?.response === 'attending' ? -1 : 0;
      setRSVPCount(prev => prev + countChange);

      onRSVP?.(event, response);
    } catch (error) {
      console.error('RSVP failed:', error);
    }
  };

  const isUpcoming = event.datetime.start > new Date();
  const timeUntilEvent = event.datetime.start.getTime() - Date.now();
  const daysUntil = Math.ceil(timeUntilEvent / (1000 * 60 * 60 * 24));

  return (
    <EventCardContainer>
      <EventImage source={{ uri: event.media[0]?.url }} />

      <EventContent>
        <EventHeader>
          <EventTitle>{event.title}</EventTitle>
          <EventType>{event.type.replace('_', ' ')}</EventType>
        </EventHeader>

        <EventDetails>
          <EventDateTime>
            <DateIcon name="calendar" />
            <DateText>
              {formatEventDate(event.datetime.start)}
              {daysUntil <= 7 && daysUntil > 0 && ` (${daysUntil} days)`}
            </DateText>
          </EventDateTime>

          <EventVenue>
            <VenueIcon name="location" />
            <VenueText>
              {event.venue.type === 'business_location' && event.venue.businessId ?
                `At ${event.organizer.name}` :
                event.venue.address?.city || 'Virtual Event'}
            </VenueText>
          </EventVenue>

          <EventCapacity>
            <PeopleIcon name="people" />
            <CapacityText>
              {rsvpCount} attending
              {event.capacity && ` (${event.capacity - rsvpCount} spots left)`}
            </CapacityText>
          </EventCapacity>
        </EventDetails>

        <EventDescription numberOfLines={3}>
          {event.description}
        </EventDescription>

        {isUpcoming && (
          <RSVPSection>
            <RSVPButtons>
              <RSVPButton
                onPress={() => handleRSVP({ response: 'attending' })}
                active={rsvpStatus?.response === 'attending'}
                color="#4CAF50"
              >
                Going
              </RSVPButton>
              <RSVPButton
                onPress={() => handleRSVP({ response: 'maybe' })}
                active={rsvpStatus?.response === 'maybe'}
                color="#FF9800"
              >
                Maybe
              </RSVPButton>
              <RSVPButton
                onPress={() => handleRSVP({ response: 'not_attending' })}
                active={rsvpStatus?.response === 'not_attending'}
                color="#f44336"
              >
                Can't Go
              </RSVPButton>
            </RSVPButtons>
          </RSVPSection>
        )}
      </EventContent>
    </EventCardContainer>
  );
};
```

### User Profile and Engagement Metrics
**Community Contribution Tracking:**
```typescript
interface UserEngagementService {
  calculateEngagementScore(userId: string): Promise<EngagementScore>;
  getUserCommunityStats(userId: string): Promise<CommunityStats>;
  getAchievements(userId: string): Promise<Achievement[]>;
  getLocalInfluenceRanking(userId: string, location: Location): Promise<InfluenceRanking>;
  updateUserContributions(userId: string, contribution: Contribution): Promise<void>;
}

interface EngagementScore {
  overall: number;
  components: {
    reviews: number;
    businessFollows: number;
    communityParticipation: number;
    socialSharing: number;
    eventAttendance: number;
  };
  tier: 'Bronze' | 'Silver' | 'Gold' | 'Platinum' | 'Diamond';
  nextTierRequirements: TierRequirement[];
}

interface CommunityStats {
  reviewsWritten: number;
  averageRating: number;
  helpfulVotes: number;
  businessesFollowed: number;
  eventsAttended: number;
  groupsJoined: number;
  postsCreated: number;
  sharesCompleted: number;
  localRanking: number;
  memberSince: Date;
}

interface Achievement {
  id: string;
  title: string;
  description: string;
  category: 'reviewer' | 'explorer' | 'connector' | 'influencer' | 'helper';
  tier: number;
  iconUrl: string;
  unlockedAt: Date;
  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';
  requirements: AchievementRequirement[];
}

// User profile with community engagement
export const UserProfile: React.FC<UserProfileProps> = ({
  user,
  isOwnProfile,
  onEdit
}) => {
  const engagementData = useUserEngagement(user.id);
  const communityStats = useCommunityStats(user.id);
  const achievements = useUserAchievements(user.id);

  return (
    <ProfileContainer>
      <ProfileHeader>
        <ProfileAvatar source={{ uri: user.profile.avatar }} />
        <ProfileInfo>
          <ProfileName>{user.profile.firstName} {user.profile.lastName}</ProfileName>
          <ProfileTitle>
            {engagementData.tier} Community Member
            <TierBadge tier={engagementData.tier} />
          </ProfileTitle>
          <ProfileLocation>
            {user.profile.locationPreferences?.city || 'Location not set'}
          </ProfileLocation>
        </ProfileInfo>
        {isOwnProfile && (
          <EditButton onPress={onEdit}>
            <EditIcon name="edit" />
          </EditButton>
        )}
      </ProfileHeader>

      <EngagementOverview>
        <EngagementTitle>Community Engagement</EngagementTitle>
        <EngagementScore>
          <ScoreValue>{engagementData.overall}</ScoreValue>
          <ScoreLabel>Engagement Score</ScoreLabel>
        </EngagementScore>
        <EngagementProgress>
          <ProgressBar
            progress={engagementData.overall / 100}
            color={getTierColor(engagementData.tier)}
          />
          <ProgressText>
            {engagementData.nextTierRequirements[0]?.description || 'Max tier reached!'}
          </ProgressText>
        </EngagementProgress>
      </EngagementOverview>

      <StatsGrid>
        <StatCard>
          <StatValue>{communityStats.reviewsWritten}</StatValue>
          <StatLabel>Reviews Written</StatLabel>
        </StatCard>
        <StatCard>
          <StatValue>{communityStats.helpfulVotes}</StatValue>
          <StatLabel>Helpful Votes</StatLabel>
        </StatCard>
        <StatCard>
          <StatValue>{communityStats.businessesFollowed}</StatValue>
          <StatLabel>Businesses Following</StatLabel>
        </StatCard>
        <StatCard>
          <StatValue>#{communityStats.localRanking}</StatValue>
          <StatLabel>Local Ranking</StatLabel>
        </StatCard>
      </StatsGrid>

      <AchievementsSection>
        <SectionTitle>Achievements</SectionTitle>
        <AchievementsList>
          {achievements.slice(0, 6).map(achievement => (
            <AchievementBadge
              key={achievement.id}
              achievement={achievement}
              size="medium"
            />
          ))}
          {achievements.length > 6 && (
            <ViewAllButton onPress={() => navigateToAchievements(user.id)}>
              +{achievements.length - 6} more
            </ViewAllButton>
          )}
        </AchievementsList>
      </AchievementsSection>

      <RecentActivity>
        <SectionTitle>Recent Activity</SectionTitle>
        <ActivityFeed userId={user.id} limit={5} />
      </RecentActivity>
    </ProfileContainer>
  );
};
```

### Database Schema Extensions
**Community Engagement Tables:**
```sql
-- Business updates/posts
CREATE TABLE business_updates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    business_id UUID NOT NULL REFERENCES businesses(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    media JSONB DEFAULT '[]',
    tags JSONB DEFAULT '[]',
    target_audience VARCHAR(50) DEFAULT 'all',
    scheduled_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    visibility VARCHAR(20) DEFAULT 'public',
    views INTEGER DEFAULT 0,
    likes INTEGER DEFAULT 0,
    shares INTEGER DEFAULT 0,
    comments INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- User-business follow relationships
CREATE TABLE user_business_follows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    business_id UUID NOT NULL REFERENCES businesses(id) ON DELETE CASCADE,
    followed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, business_id)
);

-- Community groups
CREATE TABLE community_groups (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    type VARCHAR(50) NOT NULL,
    location JSONB,
    interests JSONB DEFAULT '[]',
    member_count INTEGER DEFAULT 0,
    privacy VARCHAR(20) DEFAULT 'public',
    rules TEXT[],
    moderators UUID[],
    created_by UUID NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_activity TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Group memberships
CREATE TABLE group_memberships (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    group_id UUID NOT NULL REFERENCES community_groups(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(20) DEFAULT 'member',
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(group_id, user_id)
);

-- Community events
CREATE TABLE community_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(255) NOT NULL,
    description TEXT,
    type VARCHAR(50) NOT NULL,
    organizer_id UUID NOT NULL REFERENCES users(id),
    business_id UUID REFERENCES businesses(id),
    venue JSONB NOT NULL,
    start_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    end_datetime TIMESTAMP WITH TIME ZONE,
    capacity INTEGER,
    ticket_price DECIMAL(10,2),
    categories JSONB DEFAULT '[]',
    media JSONB DEFAULT '[]',
    rsvp_count INTEGER DEFAULT 0,
    attendance_tracking BOOLEAN DEFAULT FALSE,
    requires_approval BOOLEAN DEFAULT FALSE,
    visibility VARCHAR(20) DEFAULT 'public',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Event RSVPs
CREATE TABLE event_rsvps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id UUID NOT NULL REFERENCES community_events(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    response VARCHAR(20) NOT NULL,
    guest_count INTEGER DEFAULT 1,
    notes TEXT,
    rsvp_date TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(event_id, user_id)
);

-- User engagement scores
CREATE TABLE user_engagement_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    overall_score INTEGER NOT NULL DEFAULT 0,
    review_score INTEGER DEFAULT 0,
    follow_score INTEGER DEFAULT 0,
    community_score INTEGER DEFAULT 0,
    sharing_score INTEGER DEFAULT 0,
    event_score INTEGER DEFAULT 0,
    tier VARCHAR(20) DEFAULT 'Bronze',
    last_calculated TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id)
);

-- User achievements
CREATE TABLE user_achievements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    achievement_id VARCHAR(100) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(50) NOT NULL,
    tier INTEGER DEFAULT 1,
    rarity VARCHAR(20) DEFAULT 'common',
    unlocked_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, achievement_id)
);
```

### Testing Requirements Context
**Community Engagement Tests:**
- `apps/api/tests/functions/community/feed.test.ts`
- `apps/mobile/tests/components/CommunityFeed.test.tsx`
- `apps/api/tests/services/recommendationService.test.ts`

**Test Scenarios:**
- Business update feed generation and personalization
- Follow/unfollow functionality and notifications
- Recommendation algorithm accuracy and relevance
- Social sharing integration with external platforms
- Community group creation and management
- Event RSVP and attendance tracking
- User engagement score calculations
- Achievement unlocking and progress tracking

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-05 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

## QA Results
*To be populated by QA agent*