# Story 3.2: Service & Product Reservation

## Status
Approved

## Story
**As a** consumer,
**I want** to reserve specific products or services in advance,
**so that** I can ensure availability for items I need at my preferred pickup time.

## Acceptance Criteria
1. Product reservation system allows consumers to hold items for pickup within specified timeframe
2. Service booking supports different service types with varying durations and requirements
3. Reservation form adapts based on business type (table reservations, product holds, consultation bookings)
4. Inventory management prevents over-booking of limited quantity items
5. Pickup/appointment time selection with business-defined windows and blackout periods
6. Automatic reservation expiration with notification warnings before expiration
7. Business dashboard shows upcoming reservations with customer contact information
8. Reservation modification allows consumers to change times within business-defined policies

## Tasks / Subtasks
- [ ] **Task 1: Product Inventory Management** (AC: 1, 4)
  - [ ] Create inventory tracking system for reservable products
  - [ ] Implement ProductInventory entity with quantity management
  - [ ] Add inventory reservation with hold functionality
  - [ ] Create inventory deduction on reservation confirmation
  - [ ] Implement automatic inventory release on reservation expiration
  - [ ] Add low inventory alerts for business owners
  - [ ] Create inventory adjustment and correction tools

- [ ] **Task 2: Service Type Configuration** (AC: 2, 3)
  - [ ] Create ServiceType entity with configurable parameters
  - [ ] Implement service-specific booking requirements and forms
  - [ ] Add dynamic form generation based on service type
  - [ ] Create service duration and resource requirements
  - [ ] Implement service-specific availability calculations
  - [ ] Add service pricing variations and add-ons
  - [ ] Create service category templates for common business types

- [ ] **Task 3: Adaptive Reservation Forms** (AC: 3)
  - [ ] Create ReservationForm component with dynamic fields
  - [ ] Implement business type detection and form adaptation
  - [ ] Add form field configuration per business/service type
  - [ ] Create conditional field display based on selections
  - [ ] Implement form validation rules per reservation type
  - [ ] Add file upload support for service requirements
  - [ ] Create form state management with partial save capability

- [ ] **Task 4: Advanced Time Selection** (AC: 5)
  - [ ] Enhance time slot selection with blackout periods
  - [ ] Implement business-defined booking windows and restrictions
  - [ ] Add recurring blackout patterns (weekly, monthly closures)
  - [ ] Create special event booking with premium pricing
  - [ ] Implement multi-day reservation support
  - [ ] Add time zone handling for reservation scheduling
  - [ ] Create holiday and special hours integration

- [ ] **Task 5: Reservation Expiration System** (AC: 6)
  - [ ] Implement reservation TTL (time-to-live) management
  - [ ] Create automatic expiration handling with cleanup
  - [ ] Add expiration warning notifications (24h, 1h before expiry)
  - [ ] Implement reservation extension functionality
  - [ ] Create grace period handling for payment completion
  - [ ] Add expired reservation analytics and recovery
  - [ ] Implement expiration policy configuration per business type

- [ ] **Task 6: Business Reservation Dashboard** (AC: 7)
  - [ ] Create ReservationDashboard component for business owners
  - [ ] Implement reservation list with filtering and sorting
  - [ ] Add customer contact information and reservation details
  - [ ] Create reservation status management interface
  - [ ] Implement bulk reservation actions (confirm, cancel, modify)
  - [ ] Add reservation export for business records
  - [ ] Create reservation analytics and reporting

- [ ] **Task 7: Reservation Modification System** (AC: 8)
  - [ ] Implement reservation modification policies per business
  - [ ] Create modification request workflow with approval
  - [ ] Add modification fee calculation and processing
  - [ ] Implement automatic availability checking for modifications
  - [ ] Create modification notification system
  - [ ] Add modification history tracking
  - [ ] Implement modification deadline enforcement

- [ ] **Task 8: Enhanced Backend APIs** (AC: 1, 2, 4, 5)
  - [ ] Create POST /reservations endpoint with type-specific handling
  - [ ] Implement GET /businesses/{id}/inventory for product availability
  - [ ] Add PUT /reservations/{id}/modify for reservation changes
  - [ ] Create DELETE /reservations/{id}/cancel with policy enforcement
  - [ ] Implement GET /reservations/{id}/extend for expiration extensions
  - [ ] Add inventory locking mechanisms for concurrent reservations
  - [ ] Create reservation validation with business rules engine

## Dev Notes

### Previous Story Insights
Story 3.1 established basic booking infrastructure. This story expands reservation capabilities to handle diverse business types with product inventory, service variations, and complex scheduling requirements.

### Enhanced Reservation Data Model
**Extended Reservation Structure:**
```typescript
interface Reservation extends Booking {
  type: 'service' | 'product' | 'table' | 'consultation' | 'event';
  items?: ReservationItem[];
  requirements?: ServiceRequirements;
  expiresAt?: Date;
  modificationPolicy: ModificationPolicy;
  inventoryHolds: InventoryHold[];
}

interface ReservationItem {
  productId: string;
  quantity: number;
  price: number;
  specifications?: Record<string, any>;
  customizations?: string[];
}

interface ServiceRequirements {
  preparationTime?: number;
  resourceRequirements?: string[];
  prerequisiteDocuments?: string[];
  specialInstructions?: string;
}

interface InventoryHold {
  productId: string;
  quantity: number;
  holdUntil: Date;
  status: 'active' | 'confirmed' | 'expired' | 'released';
}
```

### Product Inventory System
**Inventory Management:**
```typescript
interface ProductInventory {
  id: string;
  businessId: string;
  productId: string;
  totalQuantity: number;
  availableQuantity: number;
  reservedQuantity: number;
  minimumStock: number;
  isTrackingEnabled: boolean;
  lastUpdated: Date;
}

interface InventoryService {
  checkAvailability(productId: string, quantity: number): Promise<boolean>;
  reserveItems(items: ReservationItem[], holdDuration: number): Promise<InventoryHold[]>;
  confirmReservation(holdIds: string[]): Promise<void>;
  releaseHold(holdIds: string[]): Promise<void>;
  updateInventory(productId: string, adjustment: number, reason: string): Promise<void>;
}
```

### Business Type Adaptations
**Service Type Configurations:**
```typescript
interface ServiceTypeConfig {
  type: 'appointment' | 'consultation' | 'workshop' | 'rental' | 'dining';
  formFields: FormFieldConfig[];
  bookingRules: BookingRules;
  pricingModel: PricingModel;
  requirements: ServiceRequirements;
}

interface FormFieldConfig {
  fieldName: string;
  fieldType: 'text' | 'select' | 'number' | 'date' | 'file' | 'checkbox';
  required: boolean;
  validation?: ValidationRule[];
  options?: SelectOption[];
  conditionalDisplay?: ConditionalLogic;
}

// Example configurations
const restaurantReservation: ServiceTypeConfig = {
  type: 'dining',
  formFields: [
    { fieldName: 'partySize', fieldType: 'number', required: true },
    { fieldName: 'seatingPreference', fieldType: 'select', required: false },
    { fieldName: 'dietaryRestrictions', fieldType: 'text', required: false }
  ],
  bookingRules: {
    advanceBookingDays: 30,
    minimumNotice: 120, // 2 hours
    maxDuration: 180    // 3 hours
  }
};
```

### Dynamic Form Generation
**Adaptive Form Component:**
```typescript
interface AdaptiveReservationFormProps {
  businessType: BusinessType;
  serviceType?: ServiceTypeConfig;
  onSubmit: (reservation: ReservationFormData) => void;
  initialData?: Partial<ReservationFormData>;
}

export const AdaptiveReservationForm: React.FC<AdaptiveReservationFormProps> = ({
  businessType,
  serviceType,
  onSubmit,
  initialData
}) => {
  const formConfig = useFormConfiguration(businessType, serviceType);
  const { control, handleSubmit, watch } = useForm({
    defaultValues: initialData
  });

  return (
    <Form>
      {formConfig.fields.map(field => (
        <DynamicFormField
          key={field.fieldName}
          config={field}
          control={control}
          watchedValues={watch()}
        />
      ))}
    </Form>
  );
};
```

### Reservation Expiration Management
**TTL and Expiration Logic:**
```typescript
interface ExpirationService {
  setReservationTTL(reservationId: string, ttlMinutes: number): Promise<void>;
  checkExpiringReservations(): Promise<Reservation[]>;
  sendExpirationWarnings(): Promise<void>;
  processExpiredReservations(): Promise<void>;
  extendReservation(reservationId: string, additionalMinutes: number): Promise<boolean>;
}

// Automated expiration processing
const processReservationExpirations = async () => {
  const expiringReservations = await reservationService.getExpiringReservations(60); // 1 hour warning

  for (const reservation of expiringReservations) {
    await notificationService.sendExpirationWarning(reservation);
  }

  const expiredReservations = await reservationService.getExpiredReservations();

  for (const reservation of expiredReservations) {
    await inventoryService.releaseHolds(reservation.inventoryHolds.map(h => h.id));
    await reservationService.markAsExpired(reservation.id);
    await notificationService.sendExpirationNotice(reservation);
  }
};
```

### Database Schema Extensions
**Additional Tables for Enhanced Reservations:**
```sql
-- Product inventory tracking
CREATE TABLE product_inventory (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    business_id UUID NOT NULL REFERENCES businesses(id),
    product_id VARCHAR(255) NOT NULL,
    total_quantity INTEGER NOT NULL DEFAULT 0,
    available_quantity INTEGER NOT NULL DEFAULT 0,
    reserved_quantity INTEGER NOT NULL DEFAULT 0,
    minimum_stock INTEGER DEFAULT 0,
    is_tracking_enabled BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Inventory holds for reservations
CREATE TABLE inventory_holds (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    reservation_id UUID NOT NULL REFERENCES bookings(id),
    product_id VARCHAR(255) NOT NULL,
    quantity_held INTEGER NOT NULL,
    hold_until TIMESTAMP WITH TIME ZONE NOT NULL,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Service type configurations
CREATE TABLE service_types (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    business_id UUID NOT NULL REFERENCES businesses(id),
    name VARCHAR(255) NOT NULL,
    type_category VARCHAR(50) NOT NULL,
    form_config JSONB NOT NULL DEFAULT '{}',
    booking_rules JSONB NOT NULL DEFAULT '{}',
    pricing_config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

### Business Dashboard Enhancements
**Reservation Management Interface:**
```typescript
interface ReservationDashboardProps {
  businessId: string;
  dateRange: [Date, Date];
  filterOptions: ReservationFilters;
}

export const ReservationDashboard: React.FC<ReservationDashboardProps> = ({
  businessId,
  dateRange,
  filterOptions
}) => {
  const reservations = useReservations(businessId, dateRange, filterOptions);
  const inventoryStatus = useInventoryStatus(businessId);

  return (
    <DashboardLayout>
      <ReservationFilters />
      <ReservationCalendar reservations={reservations} />
      <ReservationList
        reservations={reservations}
        onStatusChange={handleStatusChange}
        onModify={handleModification}
      />
      <InventoryOverview inventory={inventoryStatus} />
    </DashboardLayout>
  );
};
```

### Modification Policy Engine
**Reservation Modification Rules:**
```typescript
interface ModificationPolicy {
  allowModification: boolean;
  modificationDeadline: number; // hours before reservation
  modificationFee: number;
  allowedChanges: ModificationScope[];
  requiresApproval: boolean;
  maxModifications: number;
}

interface ModificationScope {
  field: 'time' | 'date' | 'service' | 'quantity' | 'specifications';
  restrictions?: string[];
  additionalFee?: number;
}

const evaluateModificationRequest = (
  reservation: Reservation,
  modification: ModificationRequest,
  policy: ModificationPolicy
): ModificationEvaluation => {
  const timeUntilReservation = reservation.scheduledAt.getTime() - Date.now();
  const deadlineMs = policy.modificationDeadline * 60 * 60 * 1000;

  if (timeUntilReservation < deadlineMs) {
    return { allowed: false, reason: 'Past modification deadline' };
  }

  // Additional validation logic...
  return { allowed: true, fee: calculateModificationFee(modification, policy) };
};
```

### Performance and Concurrency
**Inventory Locking for Concurrent Reservations:**
```typescript
// Pessimistic locking for inventory reservation
const reserveInventoryWithLock = async (items: ReservationItem[]) => {
  return await db.transaction(async (trx) => {
    for (const item of items) {
      const inventory = await trx('product_inventory')
        .where('product_id', item.productId)
        .forUpdate()
        .first();

      if (inventory.available_quantity < item.quantity) {
        throw new Error(`Insufficient inventory for product ${item.productId}`);
      }

      await trx('product_inventory')
        .where('product_id', item.productId)
        .update({
          available_quantity: inventory.available_quantity - item.quantity,
          reserved_quantity: inventory.reserved_quantity + item.quantity
        });

      await trx('inventory_holds').insert({
        product_id: item.productId,
        quantity_held: item.quantity,
        hold_until: new Date(Date.now() + 30 * 60 * 1000) // 30 minute hold
      });
    }
  });
};
```

### Testing Requirements Context
**Enhanced Reservation Tests:**
- `apps/api/tests/services/inventoryService.test.ts`
- `apps/mobile/tests/components/AdaptiveReservationForm.test.tsx`
- `apps/api/tests/services/expirationService.test.ts`

**Test Scenarios:**
- Product inventory reservation and release
- Service type configuration and form adaptation
- Reservation expiration and warning system
- Concurrent inventory booking scenarios
- Modification policy enforcement
- Dynamic form generation and validation
- Integration with existing booking infrastructure

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-05 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

## QA Results
*To be populated by QA agent*