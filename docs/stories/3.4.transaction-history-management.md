# Story 3.4: Transaction History & Management

## Status
Approved

## Story
**As a** consumer and business owner,
**I want** to view my transaction history and manage payment-related activities,
**so that** I can track my purchases/sales and handle any payment issues that arise.

## Acceptance Criteria
1. Consumer transaction history shows all bookings, purchases, and payment details with status tracking
2. Business owner sales dashboard displays revenue, transactions, and payout information
3. Transaction detail pages include service/product information, payment amounts, dates, and customer/business contact
4. Invoice generation for business tax reporting and consumer expense tracking
5. Dispute resolution system allows reporting of payment or service issues
6. Automatic receipt and confirmation emails for all completed transactions
7. Refund request functionality with status tracking for both parties
8. Export capability for transaction data (CSV format) for accounting purposes

## Tasks / Subtasks
- [ ] **Task 1: Consumer Transaction History** (AC: 1, 3)
  - [ ] Create TransactionHistory component for consumer dashboard
  - [ ] Implement transaction list with filtering and sorting options
  - [ ] Add transaction status indicators and progress tracking
  - [ ] Create transaction detail modal with comprehensive information
  - [ ] Implement search functionality for transactions
  - [ ] Add transaction categorization and tagging
  - [ ] Create transaction analytics and spending insights

- [ ] **Task 2: Business Sales Dashboard** (AC: 2, 3)
  - [ ] Create SalesDashboard component for business owners
  - [ ] Implement revenue analytics with charts and metrics
  - [ ] Add transaction volume and trend analysis
  - [ ] Create payout tracking and schedule display
  - [ ] Implement customer transaction summaries
  - [ ] Add sales performance comparisons and benchmarks
  - [ ] Create revenue forecasting and projections

- [ ] **Task 3: Transaction Detail System** (AC: 3)
  - [ ] Create TransactionDetail component with comprehensive information
  - [ ] Implement service/product detail display within transactions
  - [ ] Add customer and business contact information
  - [ ] Create payment method and amount breakdowns
  - [ ] Implement transaction timeline and status history
  - [ ] Add related documents and receipts display
  - [ ] Create transaction sharing and communication tools

- [ ] **Task 4: Invoice and Receipt Generation** (AC: 4, 6)
  - [ ] Create invoice generation system with customizable templates
  - [ ] Implement PDF generation for invoices and receipts
  - [ ] Add business branding and customization options
  - [ ] Create automatic receipt email delivery system
  - [ ] Implement invoice numbering and sequential tracking
  - [ ] Add tax calculation and display on invoices
  - [ ] Create invoice export and bulk generation capabilities

- [ ] **Task 5: Dispute Resolution System** (AC: 5)
  - [ ] Create dispute submission interface for consumers and businesses
  - [ ] Implement dispute categorization and priority handling
  - [ ] Add evidence upload and documentation system
  - [ ] Create dispute timeline and communication platform
  - [ ] Implement automated dispute resolution for common issues
  - [ ] Add dispute escalation and mediation workflows
  - [ ] Create dispute analytics and resolution tracking

- [ ] **Task 6: Refund Request Management** (AC: 7)
  - [ ] Create refund request interface with reason categorization
  - [ ] Implement business refund policy integration
  - [ ] Add refund approval workflow for business owners
  - [ ] Create refund status tracking and notifications
  - [ ] Implement partial refund capabilities
  - [ ] Add refund analytics and impact reporting
  - [ ] Create automated refund processing for eligible cases

- [ ] **Task 7: Data Export and Reporting** (AC: 8)
  - [ ] Implement CSV export functionality for transaction data
  - [ ] Create customizable export filters and date ranges
  - [ ] Add PDF report generation for business summaries
  - [ ] Implement scheduled report delivery via email
  - [ ] Create export templates for accounting software integration
  - [ ] Add data validation and formatting for exports
  - [ ] Implement secure export download and access control

- [ ] **Task 8: Backend API Enhancements** (AC: 1, 2, 5, 7)
  - [ ] Create GET /transactions endpoint with filtering and pagination
  - [ ] Implement GET /businesses/{id}/sales for sales dashboard
  - [ ] Add POST /disputes endpoint for dispute submission
  - [ ] Create PUT /transactions/{id}/refund for refund requests
  - [ ] Implement GET /transactions/export for data export
  - [ ] Add transaction aggregation and analytics endpoints
  - [ ] Create transaction notification and email delivery systems

## Dev Notes

### Previous Story Insights
Story 3.3 established payment processing infrastructure. This story creates the management and tracking layer that provides visibility and control over completed transactions for both consumers and businesses.

### Enhanced Transaction Management Model
**Transaction History and Management Extensions:**
```typescript
interface TransactionWithDetails extends Transaction {
  booking?: Booking;
  business: BusinessSummary;
  consumer: UserSummary;
  invoice?: Invoice;
  disputes: Dispute[];
  refunds: Refund[];
  receipts: Receipt[];
}

interface TransactionSummary {
  totalTransactions: number;
  totalRevenue: number;
  totalRefunds: number;
  averageTransactionValue: number;
  periodComparison: PeriodComparison;
  topServices: ServiceRevenue[];
  paymentMethodBreakdown: PaymentMethodStats[];
}

interface Dispute {
  id: string;
  transactionId: string;
  initiatedBy: 'consumer' | 'business';
  category: DisputeCategory;
  reason: string;
  status: DisputeStatus;
  evidence: Evidence[];
  resolution?: DisputeResolution;
  createdAt: Date;
  resolvedAt?: Date;
}

interface Refund {
  id: string;
  transactionId: string;
  amount: number;
  reason: string;
  status: 'requested' | 'approved' | 'denied' | 'processed';
  requestedBy: string;
  approvedBy?: string;
  processedAt?: Date;
  stripeRefundId?: string;
}
```

### Consumer Transaction History
**Transaction Management Interface:**
```typescript
interface TransactionHistoryProps {
  userId: string;
  filters: TransactionFilters;
  onFilterChange: (filters: TransactionFilters) => void;
}

export const TransactionHistory: React.FC<TransactionHistoryProps> = ({
  userId,
  filters,
  onFilterChange
}) => {
  const transactions = useTransactionHistory(userId, filters);
  const analytics = useTransactionAnalytics(userId, filters.dateRange);

  return (
    <HistoryContainer>
      <TransactionFilters filters={filters} onChange={onFilterChange} />
      <TransactionAnalytics data={analytics} />
      <TransactionList
        transactions={transactions}
        onTransactionSelect={handleTransactionDetail}
        onRefundRequest={handleRefundRequest}
        onDispute={handleDispute}
      />
    </HistoryContainer>
  );
};

interface TransactionFilters {
  dateRange: [Date, Date];
  status: TransactionStatus[];
  paymentMethod: string[];
  businessId?: string;
  amountRange: [number, number];
  searchQuery?: string;
}
```

### Business Sales Dashboard
**Revenue Analytics and Management:**
```typescript
interface SalesDashboardProps {
  businessId: string;
  period: DateRange;
}

export const SalesDashboard: React.FC<SalesDashboardProps> = ({
  businessId,
  period
}) => {
  const salesData = useSalesAnalytics(businessId, period);
  const payoutSchedule = usePayoutSchedule(businessId);
  const recentTransactions = useRecentTransactions(businessId, 10);

  return (
    <DashboardLayout>
      <RevenueMetrics data={salesData} />
      <RevenueChart data={salesData.timeSeries} />
      <PayoutSummary schedule={payoutSchedule} />
      <TopServices services={salesData.serviceBreakdown} />
      <RecentTransactionsList transactions={recentTransactions} />
      <CustomerInsights data={salesData.customerAnalytics} />
    </DashboardLayout>
  );
};

// Revenue analytics calculation
const calculateSalesAnalytics = (transactions: Transaction[], period: DateRange) => {
  const analytics = {
    totalRevenue: 0,
    transactionCount: 0,
    averageTransactionValue: 0,
    refundRate: 0,
    topPaymentMethods: [],
    revenueByService: [],
    customerRetentionRate: 0,
    periodGrowth: 0
  };

  // Calculate metrics from transaction data
  transactions.forEach(transaction => {
    analytics.totalRevenue += transaction.netAmount;
    analytics.transactionCount++;
    // Additional calculations...
  });

  analytics.averageTransactionValue = analytics.totalRevenue / analytics.transactionCount;

  return analytics;
};
```

### Invoice and Receipt System
**Document Generation:**
```typescript
interface InvoiceService {
  generateInvoice(transactionId: string, template?: InvoiceTemplate): Promise<Invoice>;
  generateReceipt(transactionId: string): Promise<Receipt>;
  sendReceipt(transactionId: string, email: string): Promise<void>;
  customizeInvoiceTemplate(businessId: string, template: InvoiceTemplate): Promise<void>;
}

interface Invoice {
  id: string;
  transactionId: string;
  invoiceNumber: string;
  businessDetails: BusinessInvoiceDetails;
  customerDetails: CustomerInvoiceDetails;
  lineItems: InvoiceLineItem[];
  subtotal: number;
  taxAmount: number;
  total: number;
  dueDate?: Date;
  notes?: string;
  pdfUrl: string;
  createdAt: Date;
}

// PDF generation with customization
const generateInvoicePDF = async (invoice: Invoice, template: InvoiceTemplate) => {
  const doc = new PDFDocument();

  // Business header with logo
  if (template.logo) {
    doc.image(template.logo, 50, 50, { width: 150 });
  }

  // Business information
  doc.fontSize(12)
     .text(invoice.businessDetails.name, 50, 120)
     .text(invoice.businessDetails.address, 50, 140)
     .text(invoice.businessDetails.phone, 50, 160);

  // Invoice details
  doc.fontSize(16)
     .text(`Invoice #${invoice.invoiceNumber}`, 400, 120)
     .fontSize(12)
     .text(`Date: ${invoice.createdAt.toLocaleDateString()}`, 400, 140);

  // Line items table
  let yPosition = 200;
  invoice.lineItems.forEach(item => {
    doc.text(item.description, 50, yPosition)
       .text(`$${item.amount.toFixed(2)}`, 450, yPosition);
    yPosition += 20;
  });

  // Totals
  doc.text(`Subtotal: $${invoice.subtotal.toFixed(2)}`, 400, yPosition + 20)
     .text(`Tax: $${invoice.taxAmount.toFixed(2)}`, 400, yPosition + 40)
     .fontSize(14)
     .text(`Total: $${invoice.total.toFixed(2)}`, 400, yPosition + 60);

  return doc;
};
```

### Dispute Resolution System
**Dispute Management Workflow:**
```typescript
interface DisputeService {
  createDispute(params: CreateDisputeParams): Promise<Dispute>;
  addEvidence(disputeId: string, evidence: Evidence): Promise<void>;
  updateDisputeStatus(disputeId: string, status: DisputeStatus, resolution?: string): Promise<void>;
  getDisputeMessages(disputeId: string): Promise<DisputeMessage[]>;
  resolveDispute(disputeId: string, resolution: DisputeResolution): Promise<void>;
}

interface CreateDisputeParams {
  transactionId: string;
  category: 'service_not_received' | 'service_unsatisfactory' | 'billing_error' | 'refund_issue';
  description: string;
  evidence: Evidence[];
  requestedResolution: string;
}

// Automated dispute resolution for common issues
const processAutomaticDispute = async (dispute: Dispute) => {
  switch (dispute.category) {
    case 'service_not_received':
      if (isServiceDatePassed(dispute.transaction.scheduledAt)) {
        return await processAutomaticRefund(dispute.transactionId, 'service_not_provided');
      }
      break;

    case 'billing_error':
      const calculationError = await validateBillingCalculation(dispute.transactionId);
      if (calculationError) {
        return await processPartialRefund(dispute.transactionId, calculationError.amount);
      }
      break;

    default:
      return await escalateToManualReview(dispute);
  }
};
```

### Refund Management System
**Refund Processing Workflow:**
```typescript
interface RefundService {
  requestRefund(params: RefundRequestParams): Promise<RefundRequest>;
  approveRefund(refundId: string, approverId: string): Promise<void>;
  processRefund(refundId: string): Promise<RefundResult>;
  getRefundEligibility(transactionId: string): Promise<RefundEligibility>;
}

interface RefundRequestParams {
  transactionId: string;
  amount?: number; // If not provided, full refund
  reason: string;
  category: 'cancellation' | 'service_issue' | 'billing_error' | 'other';
}

interface RefundEligibility {
  eligible: boolean;
  reason?: string;
  maxRefundAmount: number;
  cutoffDate?: Date;
  requiresApproval: boolean;
  automaticProcessing: boolean;
}

// Business refund policy evaluation
const evaluateRefundEligibility = async (transactionId: string): Promise<RefundEligibility> => {
  const transaction = await getTransactionById(transactionId);
  const business = await getBusinessById(transaction.businessId);
  const refundPolicy = business.refundPolicy;

  const hoursSinceTransaction = (Date.now() - transaction.createdAt.getTime()) / (1000 * 60 * 60);

  if (hoursSinceTransaction > refundPolicy.cutoffHours) {
    return {
      eligible: false,
      reason: 'Past refund deadline',
      maxRefundAmount: 0,
      requiresApproval: false,
      automaticProcessing: false
    };
  }

  return {
    eligible: true,
    maxRefundAmount: transaction.amount,
    requiresApproval: refundPolicy.requiresApproval,
    automaticProcessing: refundPolicy.automaticProcessing && hoursSinceTransaction <= 24
  };
};
```

### Data Export and Reporting
**Export Service Implementation:**
```typescript
interface ExportService {
  exportTransactions(params: ExportParams): Promise<ExportResult>;
  generateReport(params: ReportParams): Promise<Report>;
  scheduleRecurringReport(params: ScheduledReportParams): Promise<void>;
}

interface ExportParams {
  businessId?: string;
  userId?: string;
  dateRange: [Date, Date];
  format: 'csv' | 'pdf' | 'json';
  filters: TransactionFilters;
  fields: string[];
}

// CSV export generation
const generateTransactionCSV = (transactions: TransactionWithDetails[]): string => {
  const headers = [
    'Transaction ID', 'Date', 'Business', 'Service', 'Amount',
    'Tax', 'Fees', 'Net Amount', 'Status', 'Payment Method'
  ];

  const rows = transactions.map(transaction => [
    transaction.id,
    transaction.createdAt.toISOString(),
    transaction.business.name,
    transaction.booking?.serviceId || 'N/A',
    transaction.amount.toFixed(2),
    transaction.taxAmount.toFixed(2),
    transaction.platformFee.toFixed(2),
    transaction.netAmount.toFixed(2),
    transaction.status,
    transaction.paymentMethod.type
  ]);

  return [headers, ...rows]
    .map(row => row.map(field => `"${field}"`).join(','))
    .join('\n');
};
```

### Database Schema Extensions
**Transaction Management Tables:**
```sql
-- Disputes table
CREATE TABLE disputes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    transaction_id UUID NOT NULL REFERENCES transactions(id),
    initiated_by UUID NOT NULL REFERENCES users(id),
    category VARCHAR(50) NOT NULL,
    description TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'open',
    requested_resolution TEXT,
    resolution TEXT,
    resolved_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    resolved_at TIMESTAMP WITH TIME ZONE
);

-- Refunds table
CREATE TABLE refunds (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    transaction_id UUID NOT NULL REFERENCES transactions(id),
    amount DECIMAL(10,2) NOT NULL,
    reason TEXT NOT NULL,
    category VARCHAR(50) NOT NULL,
    status VARCHAR(20) DEFAULT 'requested',
    requested_by UUID NOT NULL REFERENCES users(id),
    approved_by UUID REFERENCES users(id),
    stripe_refund_id VARCHAR(255),
    processed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Invoices table
CREATE TABLE invoices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    transaction_id UUID NOT NULL REFERENCES transactions(id),
    invoice_number VARCHAR(50) UNIQUE NOT NULL,
    pdf_url TEXT,
    email_sent_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

### Testing Requirements Context
**Transaction Management Tests:**
- `apps/api/tests/functions/transactions/history.test.ts`
- `apps/mobile/tests/components/TransactionHistory.test.tsx`
- `apps/api/tests/services/disputeService.test.ts`

**Test Scenarios:**
- Transaction history filtering and pagination
- Sales dashboard analytics calculations
- Invoice and receipt generation
- Dispute creation and resolution workflows
- Refund request processing and approval
- Data export functionality and formats
- Email delivery for receipts and notifications
- Performance testing for large transaction datasets

### Performance and Analytics Context
**Transaction Data Optimization:**
- Database indexing for efficient transaction queries
- Caching for frequently accessed transaction summaries
- Async processing for large data exports
- Real-time analytics with incremental updates
- Data archiving for old transaction records

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-05 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

## QA Results
*To be populated by QA agent*