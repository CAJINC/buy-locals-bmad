# Story 4.2: Business Response to Reviews

## Status
Approved

## Story
**As a** business owner,
**I want** to respond to customer reviews and engage with feedback,
**so that** I can address concerns, thank customers, and demonstrate my commitment to customer service.

## Acceptance Criteria
1. Business owner notification system alerts when new reviews are posted
2. Response interface allows businesses to reply to individual reviews with formatted text
3. Response character limits encourage concise, professional communication
4. Public response display shows business name and response date clearly
5. Response editing capability with version history for transparency
6. Guidelines and best practices provided for professional review responses
7. Flagging system allows reporting of inappropriate reviews or responses
8. Response analytics show engagement rates and customer follow-up metrics

## Tasks / Subtasks
- [ ] **Task 1: Review Notification System** (AC: 1)
  - [ ] Implement real-time notifications for new reviews
  - [ ] Create email notification templates for business owners
  - [ ] Add push notification system for mobile business app
  - [ ] Implement notification preferences and frequency settings
  - [ ] Create notification digest options (immediate, daily, weekly)
  - [ ] Add notification analytics and delivery tracking
  - [ ] Implement notification filtering by review rating/type

- [ ] **Task 2: Business Response Interface** (AC: 2, 3)
  - [ ] Create BusinessResponseForm component with rich text editor
  - [ ] Implement character limit validation with real-time counter
  - [ ] Add response templates for common scenarios
  - [ ] Create response preview before publishing
  - [ ] Implement response draft saving and recovery
  - [ ] Add response tone analysis and suggestions
  - [ ] Create mobile-optimized response interface

- [ ] **Task 3: Response Display System** (AC: 4)
  - [ ] Create ResponseCard component for public display
  - [ ] Implement business name and branding in responses
  - [ ] Add response timestamp and relative time display
  - [ ] Create response threading with review connection
  - [ ] Implement response highlighting and emphasis
  - [ ] Add response sharing and link generation
  - [ ] Create responsive response display across devices

- [ ] **Task 4: Response Editing and History** (AC: 5)
  - [ ] Implement response editing with version control
  - [ ] Create edit history tracking and display
  - [ ] Add edit reason collection and categorization
  - [ ] Implement edit notifications to original reviewer
  - [ ] Create edit window restrictions and policies
  - [ ] Add edit analytics and pattern tracking
  - [ ] Implement collaborative editing for business teams

- [ ] **Task 5: Response Guidelines and Training** (AC: 6)
  - [ ] Create response guidelines documentation
  - [ ] Implement contextual tips during response composition
  - [ ] Add response quality scoring and feedback
  - [ ] Create response template library with examples
  - [ ] Implement response coaching and suggestions
  - [ ] Add professional communication training resources
  - [ ] Create response best practices dashboard

- [ ] **Task 6: Content Flagging System** (AC: 7)
  - [ ] Implement review and response flagging interface
  - [ ] Create flag categorization and priority system
  - [ ] Add community reporting for inappropriate content
  - [ ] Implement automated content moderation scanning
  - [ ] Create moderation queue for flagged content
  - [ ] Add appeal process for flagged responses
  - [ ] Implement flagging analytics and abuse prevention

- [ ] **Task 7: Response Analytics Dashboard** (AC: 8)
  - [ ] Create business response analytics interface
  - [ ] Implement engagement rate calculations and tracking
  - [ ] Add response time metrics and benchmarking
  - [ ] Create customer follow-up and conversion tracking
  - [ ] Implement response sentiment analysis
  - [ ] Add competitive response analysis
  - [ ] Create response ROI and impact measurements

- [ ] **Task 8: Backend Response Management** (AC: 1, 2, 5, 7)
  - [ ] Create POST /reviews/{id}/respond endpoint
  - [ ] Implement PUT /responses/{id} for response editing
  - [ ] Add GET /businesses/{id}/response-analytics endpoint
  - [ ] Create notification service for review alerts
  - [ ] Implement response validation and moderation
  - [ ] Add response flagging and reporting endpoints
  - [ ] Create response export and backup functionality

## Dev Notes

### Previous Story Insights
Story 4.1 established the review system foundation. This story enables business owners to engage with customers, creating a two-way communication channel that builds trust and demonstrates customer service commitment.

### Business Response Data Model
**Response Management Structure:**
```typescript
interface BusinessResponse {
  id: string;
  reviewId: string;
  businessId: string;
  responderId: string; // Business owner or authorized user
  content: string;
  status: 'published' | 'draft' | 'flagged' | 'removed';
  editHistory: ResponseEdit[];
  flags: ResponseFlag[];
  analytics: ResponseAnalytics;
  createdAt: Date;
  updatedAt: Date;
  publishedAt?: Date;
}

interface ResponseEdit {
  id: string;
  editedAt: Date;
  previousContent: string;
  reason?: string;
  editedBy: string;
}

interface ResponseAnalytics {
  views: number;
  engagement: number;
  helpfulVotes: number;
  customerFollowUp: boolean;
  sentimentScore: number;
}
```

### Notification System Architecture
**Review Alert Management:**
```typescript
interface ReviewNotificationService {
  notifyNewReview(review: Review): Promise<void>;
  subscribeToReviewNotifications(businessId: string, preferences: NotificationPreferences): Promise<void>;
  sendDigestNotifications(): Promise<void>;
  trackNotificationDelivery(notificationId: string, status: string): Promise<void>;
}

interface NotificationPreferences {
  immediate: boolean;
  dailyDigest: boolean;
  weeklyDigest: boolean;
  emailEnabled: boolean;
  pushEnabled: boolean;
  smsEnabled: boolean;
  minimumRating?: number; // Only notify for reviews below this rating
}

// Real-time notification implementation
const notifyNewReview = async (review: Review) => {
  const business = await getBusinessById(review.businessId);
  const preferences = await getNotificationPreferences(business.ownerId);

  if (preferences.immediate) {
    const notification = {
      title: 'New Review Received',
      body: `${review.rating}⭐ review from ${review.authorName}`,
      data: {
        reviewId: review.id,
        businessId: review.businessId,
        rating: review.rating
      }
    };

    if (preferences.pushEnabled) {
      await sendPushNotification(business.ownerId, notification);
    }

    if (preferences.emailEnabled) {
      await sendEmailNotification(business.owner.email, notification);
    }
  }
};
```

### Response Interface Components
**Business Response Management:**
```typescript
interface BusinessResponseFormProps {
  review: Review;
  existingResponse?: BusinessResponse;
  onResponseSubmit: (response: ResponseSubmission) => void;
  onSaveDraft: (draft: ResponseDraft) => void;
}

export const BusinessResponseForm: React.FC<BusinessResponseFormProps> = ({
  review,
  existingResponse,
  onResponseSubmit,
  onSaveDraft
}) => {
  const [content, setContent] = useState(existingResponse?.content || '');
  const [characterCount, setCharacterCount] = useState(0);
  const maxCharacters = 1000;

  const responseTemplates = useResponseTemplates(review.rating);
  const [showGuidelines, setShowGuidelines] = useState(false);

  const handleTemplateSelect = (template: ResponseTemplate) => {
    setContent(template.content);
  };

  const handleSubmit = async () => {
    if (content.trim().length === 0) return;

    const response: ResponseSubmission = {
      reviewId: review.id,
      content: content.trim(),
      responseType: getResponseType(review.rating),
      sentiment: await analyzeSentiment(content)
    };

    onResponseSubmit(response);
  };

  return (
    <ResponseFormContainer>
      <ReviewContext review={review} />

      <ResponseTemplateSelector
        templates={responseTemplates}
        onTemplateSelect={handleTemplateSelect}
      />

      <ResponseEditor
        value={content}
        onChange={setContent}
        maxLength={maxCharacters}
        onCharacterCountChange={setCharacterCount}
        placeholder="Write a professional response..."
      />

      <ResponseMetrics
        characterCount={characterCount}
        maxCharacters={maxCharacters}
        sentimentScore={content ? await analyzeSentiment(content) : null}
      />

      <ResponseGuidelines
        visible={showGuidelines}
        onClose={() => setShowGuidelines(false)}
      />

      <ResponseActions
        onSubmit={handleSubmit}
        onSaveDraft={() => onSaveDraft({ content, reviewId: review.id })}
        onShowGuidelines={() => setShowGuidelines(true)}
        submitDisabled={content.trim().length === 0}
      />
    </ResponseFormContainer>
  );
};
```

### Response Templates System
**Contextual Response Suggestions:**
```typescript
interface ResponseTemplate {
  id: string;
  category: 'thank_positive' | 'address_negative' | 'request_details' | 'apologize_issue';
  rating: number; // Template suggested for reviews of this rating
  content: string;
  variables: TemplateVariable[];
}

const responseTemplates: ResponseTemplate[] = [
  {
    id: 'thank_positive_5star',
    category: 'thank_positive',
    rating: 5,
    content: 'Thank you so much for your wonderful review, {customerName}! We\'re thrilled that you had such a positive experience with {serviceName}. Your feedback means the world to us and motivates our team to continue providing excellent service.',
    variables: [
      { name: 'customerName', type: 'string', required: false },
      { name: 'serviceName', type: 'string', required: false }
    ]
  },
  {
    id: 'address_negative_2star',
    category: 'address_negative',
    rating: 2,
    content: 'Thank you for bringing this to our attention, {customerName}. We sincerely apologize that your experience didn\'t meet your expectations. We\'d love the opportunity to make this right. Please contact us directly at {contactInfo} so we can resolve this issue.',
    variables: [
      { name: 'customerName', type: 'string', required: false },
      { name: 'contactInfo', type: 'string', required: true }
    ]
  }
];

const getResponseTemplates = (reviewRating: number): ResponseTemplate[] => {
  return responseTemplates.filter(template => {
    if (reviewRating >= 4) return template.category === 'thank_positive';
    if (reviewRating <= 2) return template.category === 'address_negative';
    return template.category === 'request_details';
  });
};
```

### Response Guidelines System
**Professional Communication Training:**
```typescript
interface ResponseGuidelines {
  category: string;
  title: string;
  guidelines: Guideline[];
  examples: ResponseExample[];
}

interface Guideline {
  id: string;
  rule: string;
  explanation: string;
  importance: 'critical' | 'important' | 'helpful';
}

const responseGuidelines: ResponseGuidelines[] = [
  {
    category: 'positive_reviews',
    title: 'Responding to Positive Reviews',
    guidelines: [
      {
        id: 'thank_specifically',
        rule: 'Thank the customer and mention specific details',
        explanation: 'Reference specific services or experiences mentioned in their review',
        importance: 'important'
      },
      {
        id: 'keep_brief',
        rule: 'Keep responses concise and genuine',
        explanation: 'Avoid overly long responses that seem automated',
        importance: 'helpful'
      }
    ],
    examples: [
      {
        scenario: '5-star review mentioning great service',
        goodResponse: 'Thank you for the wonderful review! We\'re so happy you enjoyed our customer service.',
        badResponse: 'Thanks for the review. We appreciate all feedback.'
      }
    ]
  }
];
```

### Response Analytics Dashboard
**Engagement and Impact Metrics:**
```typescript
interface ResponseAnalyticsService {
  calculateEngagementRate(businessId: string, period: DateRange): Promise<number>;
  getResponseTimeMetrics(businessId: string): Promise<ResponseTimeMetrics>;
  trackCustomerFollowUp(responseId: string, followUpType: string): Promise<void>;
  generateResponseReport(businessId: string, period: DateRange): Promise<ResponseReport>;
}

interface ResponseTimeMetrics {
  averageResponseTime: number; // in hours
  responseRate: number; // percentage of reviews responded to
  fastResponseCount: number; // responses within 24 hours
  benchmarkComparison: BenchmarkData;
}

// Response analytics calculation
const calculateResponseEngagement = async (businessId: string) => {
  const responses = await db('business_responses')
    .join('reviews', 'business_responses.review_id', 'reviews.id')
    .where('reviews.business_id', businessId)
    .where('business_responses.status', 'published');

  const totalReviews = await db('reviews')
    .where('business_id', businessId)
    .count('* as count')
    .first();

  const responseRate = (responses.length / totalReviews.count) * 100;

  const engagement = responses.reduce((acc, response) => {
    return acc + (response.helpful_votes || 0) + (response.views || 0);
  }, 0) / responses.length;

  return {
    responseRate,
    averageEngagement: engagement,
    totalResponses: responses.length,
    responseTrends: calculateTrends(responses)
  };
};
```

### Content Moderation and Flagging
**Response Quality Control:**
```typescript
interface ContentModerationService {
  flagContent(contentId: string, contentType: 'review' | 'response', reason: string, reporterId: string): Promise<void>;
  moderateContent(contentId: string, decision: 'approve' | 'reject', reason?: string): Promise<void>;
  getContentFlags(contentId: string): Promise<ContentFlag[]>;
  processModerationQueue(): Promise<void>;
}

interface ContentFlag {
  id: string;
  contentId: string;
  contentType: 'review' | 'response';
  reason: string;
  category: 'spam' | 'inappropriate' | 'offensive' | 'fake' | 'other';
  reporterId: string;
  status: 'pending' | 'reviewed' | 'resolved';
  moderatorNotes?: string;
  createdAt: Date;
}

// Automated content screening
const screenResponseContent = async (content: string): Promise<ModerationResult> => {
  const profanityCheck = await checkProfanity(content);
  const sentimentAnalysis = await analyzeSentiment(content);
  const spamCheck = await detectSpam(content);

  let flags = [];
  let requiresReview = false;

  if (profanityCheck.containsProfanity) {
    flags.push('profanity');
    requiresReview = true;
  }

  if (sentimentAnalysis.score < -0.8) {
    flags.push('negative_sentiment');
    requiresReview = true;
  }

  if (spamCheck.isSpam) {
    flags.push('spam');
    requiresReview = true;
  }

  return {
    approved: !requiresReview,
    flags,
    confidence: Math.min(profanityCheck.confidence, sentimentAnalysis.confidence, spamCheck.confidence)
  };
};
```

### Database Schema Extensions
**Business Response Tables:**
```sql
-- Business responses table
CREATE TABLE business_responses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    review_id UUID NOT NULL REFERENCES reviews(id) ON DELETE CASCADE,
    business_id UUID NOT NULL REFERENCES businesses(id) ON DELETE CASCADE,
    responder_id UUID NOT NULL REFERENCES users(id),
    content TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'published',
    helpful_votes INTEGER DEFAULT 0,
    views INTEGER DEFAULT 0,
    sentiment_score DECIMAL(3,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    published_at TIMESTAMP WITH TIME ZONE
);

-- Response edit history
CREATE TABLE response_edits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    response_id UUID NOT NULL REFERENCES business_responses(id) ON DELETE CASCADE,
    previous_content TEXT NOT NULL,
    reason TEXT,
    edited_by UUID NOT NULL REFERENCES users(id),
    edited_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Content flags for reviews and responses
CREATE TABLE content_flags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content_id UUID NOT NULL,
    content_type VARCHAR(20) NOT NULL CHECK (content_type IN ('review', 'response')),
    reason TEXT NOT NULL,
    category VARCHAR(50) NOT NULL,
    reporter_id UUID NOT NULL REFERENCES users(id),
    status VARCHAR(20) DEFAULT 'pending',
    moderator_id UUID REFERENCES users(id),
    moderator_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    resolved_at TIMESTAMP WITH TIME ZONE
);
```

### Testing Requirements Context
**Business Response Tests:**
- `apps/api/tests/functions/review/respond.test.ts`
- `apps/mobile/tests/components/BusinessResponseForm.test.tsx`
- `apps/api/tests/services/notificationService.test.ts`

**Test Scenarios:**
- Response creation and publishing workflow
- Notification delivery for new reviews
- Response editing and history tracking
- Content flagging and moderation system
- Response analytics calculation
- Template system and suggestions
- Character limit validation and enforcement
- Professional guidelines integration

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-05 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*To be populated by development agent*

### Debug Log References
*To be populated by development agent*

### Completion Notes List
*To be populated by development agent*

### File List
*To be populated by development agent*

## QA Results
*To be populated by QA agent*